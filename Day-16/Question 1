3562. Maximum Profit from Trading Stocks with Discounts
Solution 

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int B;
    vector<int> p, f;
    vector<vector<int>> g;
    vector<vector<int>> dp0, dp1;
    const int NEG = -1000000000;

    void dfs(int u) {
        vector<int> cur0(B + 1, NEG), cur1(B + 1, NEG);
        cur0[0] = 0;
        cur1[0] = 0;
        for (int v : g[u]) {
            dfs(v);
            vector<int> nc0(B + 1, NEG), nc1(B + 1, NEG);
            for (int i = 0; i <= B; ++i) if (cur0[i] > NEG/2) {
                for (int j = 0; j + i <= B; ++j) if (dp0[v][j] > NEG/2) {
                    nc0[i + j] = max(nc0[i + j], cur0[i] + dp0[v][j]);
                }
            }
            for (int i = 0; i <= B; ++i) if (cur1[i] > NEG/2) {
                for (int j = 0; j + i <= B; ++j) if (dp1[v][j] > NEG/2) {
                    nc1[i + j] = max(nc1[i + j], cur1[i] + dp1[v][j]);
                }
            }
            cur0.swap(nc0);
            cur1.swap(nc1);
        }
        dp0[u] = cur0;
        dp1[u] = cur0;
        int full = p[u];
        int disc = p[u] / 2;
        int profFull = f[u] - full;
        int profDisc = f[u] - disc;
        for (int x = 0; x + full <= B; ++x) if (cur1[x] > NEG/2) {
            dp0[u][x + full] = max(dp0[u][x + full], cur1[x] + profFull);
        }
        for (int x = 0; x + disc <= B; ++x) if (cur1[x] > NEG/2) {
            dp1[u][x + disc] = max(dp1[u][x + disc], cur1[x] + profDisc);
        }
    }

    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        B = budget;
        p = present;
        f = future;
        g.assign(n, {});
        for (auto &e : hierarchy) g[e[0] - 1].push_back(e[1] - 1);
        dp0.assign(n, vector<int>(B + 1, NEG));
        dp1.assign(n, vector<int>(B + 1, NEG));
        dfs(0);
        int ans = 0;
        for (int b = 0; b <= B; ++b) ans = max(ans, dp0[0][b]);
        return ans;
    }
};
