3562. Maximum Profit from Trading Stocks with Discounts
Solution 

class Solution {
public:
    int n, B;
    vector<int> present, future;
    vector<vector<int>> tree;
    vector<vector<int>> dp0, dp1;
    void dfs(int u) {
        dp0[u] = vector<int>(B + 1, 0);
        dp1[u] = vector<int>(B + 1, 0);
        for (int v : tree[u]) {
            dfs(v);
            vector<int> ndp0(B + 1, -1000000000);
            vector<int> ndp1(B + 1, -1000000000);
            for (int i = 0; i <= B; i++) {
                if (dp0[u][i] < 0) continue;
                for (int j = 0; j + i <= B; j++) {
                    ndp0[i + j] = max(ndp0[i + j], dp0[u][i] + dp0[v][j]);
                }
            }
            for (int i = 0; i <= B; i++) {
                if (dp1[u][i] < 0) continue;
                for (int j = 0; j + i <= B; j++) {
                    ndp1[i + j] = max(ndp1[i + j], dp1[u][i] + dp1[v][j]);
                }
            }
            dp0[u] = ndp0;
            dp1[u] = ndp1;
        }
        for (int b = B; b >= 0; b--) {
            int c0 = present[u];
            if (b >= c0) {
                dp0[u][b] = max(dp0[u][b], dp1[u][b - c0] + future[u] - c0);
            }
            int c1 = present[u] / 2;
            if (b >= c1) {
                dp1[u][b] = max(dp1[u][b], dp1[u][b - c1] + future[u] - c1);
            }
        }
    }
    int maxProfit(int n, vector<int>& present, vector<int>& future,
                  vector<vector<int>>& hierarchy, int budget) {
        this->n = n;
        this->present = present;
        this->future = future;
        B = budget;
        tree.assign(n, {});
        for (auto &e : hierarchy) {
            tree[e[0] - 1].push_back(e[1] - 1);
        }
        dp0.resize(n);
        dp1.resize(n);
        dfs(0);
        int ans = 0;
        for (int b = 0; b <= B; b++) {
            ans = max(ans, dp0[0][b]);
        }
        return ans;
    }
};
